package com.tommyhasselman.termsconditions.model;

import com.tommyhasselman.termsconditions.Controller;

import java.util.Collections;
import java.util.ArrayList;
import java.util.Random;

/**
 *  The Order class describes a order and a package of items to be displayed to the player.
 */
@SuppressWarnings("unused")
public class Order {

    private ArrayList<OrderItem> ordered = new ArrayList<>(); // Array of items on the order.
    private ArrayList<OrderItem> packed = new ArrayList<>(); // Array of items that have been packed.
    private ArrayList<OrderItem> packedShuff = new ArrayList<>();
    private boolean correctlyPacked;
    private boolean validated;

    /**
     * Order constructor populates the ordered and packed arrays.
     * The Random class is used to decide if the items in the packed array
     * match the ones in the ordered array.
     */
    public Order(Controller c) {

        int comp = c.getOrderItemComplexity();

        // Fills the ordered array with random items generated by the BasicItem class
        for (int i = 0; i < c.orderSize; i++){
            ordered.add(new Item(comp));
        }

        // Fills the packed array with matching or mismatching items.
        Random r = new Random();
        for (OrderItem i : ordered) {
            double chance = r.nextDouble();
            if (chance > c.incorrectItemChance) {
                packed.add(i);
                packedShuff.add(i);
            } else {
                // If the chance is less than missingItemChance the item will be skipped.
                if (chance > c.missingItemChance) {
                    Item item = new Item(comp);
                    packed.add(item); // There is a small chance that this item will happen to be the same at the moment.
                    packedShuff.add(item);
                }
            }
        }

        correctlyPacked = (getOrderedCodes().equals(getPackedCodes()));
        Collections.shuffle(packedShuff);

    }

    /**
     * Concatenates the OrderItem codes for the ordered array for comparison.
     * @return Returns a String of OrderItem codes.
     */
    public String getOrderedCodes() {
        StringBuilder s = new StringBuilder();
        for (OrderItem i : ordered) {
            s.append(i.getCode());
        }
        return s.toString();
    }

    /**
     * Concatenates the OrderItem codes for the packed array for comparison.
     * @return Returns a String of OrderItem codes.
     */
    public String getPackedCodes() {
        StringBuilder s = new StringBuilder();
        for (OrderItem i : packed) {
            s.append(i.getCode());
        }
        return s.toString();
    }

    public ArrayList<OrderItem> getPacked() {
        return packed;
    }

    public ArrayList<OrderItem> getPackedShuff() {
        return packedShuff;
    }

    public ArrayList<OrderItem> getOrdered() {
        return ordered;
    }

    public void setOrdered(ArrayList<OrderItem> ordered) {
        this.ordered = ordered;
    }

    public void setPacked(ArrayList<OrderItem> packed) {
        this.packed = packed;
    }

    public boolean isValidated() {
        return validated;
    }

    public void setValidated(boolean validated) {
        this.validated = validated;
    }

    public boolean isCorrectlyPacked() {
        return correctlyPacked;
    }
}
